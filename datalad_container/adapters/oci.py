"""Run a container from the image in a local OCI directory.

This adapter uses Skopeo to save a Docker image (or any source that Skopeo
supports) to a local directory that's compliant with the "Open Container Image
Layout Specification" and can be tracked as objects in a DataLad dataset.

This image can then be loaded on-the-fly in order for execution.

Examples
--------

Save BusyBox 1.32 from Docker Hub to the local directory bb_1.32:

    $ python -m datalad_container.adapters.oci \\
      save docker://busybox:1.32 bb-1.32/

Load the image into the Docker daemon (if necessary) and run a command:

    $ python -m datalad_container.adapters.oci \\
      run bb_1.32/ sh -c 'busybox | head -1'
    BusyBox v1.32.0 (2020-10-12 23:47:18 UTC) multi-call binary.
"""

import json
import logging
from pathlib import Path
import re
import subprocess as sp
import sys

from datalad_container.adapters.utils import (
    docker_run,
    get_docker_image_ids,
    log_and_exit,
    setup_logger,
)

lgr = logging.getLogger("datalad.container.adapters.oci")


def save(image, path):
    """Save an image to an OCI-compliant directory.

    Parameters
    ----------
    image : str
        A source image accepted by skopeo-copy
    path : pathlib.Path
        Directory to copy the image to
    """
    # Refuse to work with non-empty directory if it's not empty by letting the
    # OSError through. Multiple images can be saved to an OCI directory, but
    # run() and get_image_id() don't support a way to pull out a specific one.
    try:
        path.rmdir()
    except FileNotFoundError:
        pass
    except OSError as exc:
        raise OSError(exc) from None
    path.mkdir(parents=True)
    sp.run(["skopeo", "copy", image, "oci:" + str(path)],
           check=True)


def get_image_id(path):
    """Return a directory's image ID.

    Parameters
    ----------
    path : pathlib.Path
        Image directory. It must contain only one image.

    Returns
    -------
    An image ID (str)
    """
    # Note: This adapter depends on one image per directory. If, outside of
    # this adapter interface, multiple images were stored in a directory, this
    # will inspect call fails with a reasonable message.
    res = sp.run(["skopeo", "inspect", "--raw", "oci:" + str(path)],
                 stdout=sp.PIPE, stderr=sp.PIPE,
                 universal_newlines=True, check=True)
    info = json.loads(res.stdout)
    return info["config"]["digest"]


def load(path):
    """Load OCI image from `path`.

    Currently the only supported load destination is the Docker daemon.

    Parameters
    ----------
    path : pathlib.Path
        An OCI-compliant directory such as the one generated by `save`. It must
        contain only one image.

    Returns
    -------
    An image ID (str)
    """
    image_id = get_image_id(path)
    if image_id not in get_docker_image_ids():
        lgr.debug("Loading %s", image_id)
        # The image is copied with a datalad-container/ prefix to reduce the
        # chance of collisions with existing names registered with the Docker
        # daemon. While we must specify _something_ for the name and tag in
        # order to copy it, the particular values don't matter for execution
        # purposes; they're chosen to help users identify the container in the
        # `docker images` output.
        name = re.sub("[^a-z0-9-_.]", "", path.name.lower()[:10])
        assert image_id.startswith("sha256:")
        tag = image_id.replace(":", "-")[:14]

        lgr.debug("Copying %s to Docker daemon", image_id)
        sp.run(["skopeo", "copy", "oci:" + str(path),
                "docker-daemon:datalad-container/{}:{}".format(name, tag)],
               check=True)
    else:
        lgr.debug("Image %s is already present", image_id)
    return image_id


# Command-line


def cli_save(namespace):
    save(namespace.image, namespace.path)


def cli_run(namespace):
    image_id = load(namespace.path)
    docker_run(image_id, namespace.cmd)


def main(args):
    import argparse

    parser = argparse.ArgumentParser(
        prog="python -m datalad_container.adapters.oci",
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument(
        "-v", "--verbose",
        action="store_true")

    subparsers = parser.add_subparsers(title="subcommands")
    # Don't continue without a subcommand.
    subparsers.required = True
    subparsers.dest = "command"

    parser_save = subparsers.add_parser(
        "save",
        help="save an image to a directory")
    parser_save.add_argument(
        "image", metavar="NAME",
        help="image to save")
    parser_save.add_argument(
        "path", metavar="PATH", type=Path,
        help="directory to save image in")
    parser_save.set_defaults(func=cli_save)

    parser_run = subparsers.add_parser(
        "run",
        help="run a command with a directory's image")

    parser_run.add_argument(
        "path", metavar="PATH", type=Path,
        help="image directory")
    parser_run.add_argument(
        "cmd", metavar="CMD", nargs=argparse.REMAINDER,
        help="command to execute")
    parser_run.set_defaults(func=cli_run)

    namespace = parser.parse_args(args[1:])

    setup_logger(logging.DEBUG if namespace.verbose else logging.INFO)

    namespace.func(namespace)


if __name__ == "__main__":
    with log_and_exit(lgr):
        main(sys.argv)
